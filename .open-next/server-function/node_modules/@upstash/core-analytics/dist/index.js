"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  Analytics: () => Analytics
});
module.exports = __toCommonJS(src_exports);

// src/analytics.ts
var Key = class {
  constructor(prefix, table, bucket) {
    this.prefix = prefix;
    this.table = table;
    this.bucket = bucket;
  }
  toString() {
    return [this.prefix, this.table, this.bucket].join(":");
  }
  static fromString(key) {
    const [prefix, table, bucket] = key.split(":");
    return new Key(prefix, table, parseInt(bucket));
  }
};
var Cache = class {
  cache;
  ttl;
  constructor(ttl) {
    this.cache = /* @__PURE__ */ new Map();
    this.ttl = ttl;
    setInterval(() => {
      const now = Date.now();
      for (const [key, { createdAt }] of this.cache) {
        if (now - createdAt > this.ttl) {
          this.cache.delete(key);
        }
      }
    }, this.ttl * 10);
  }
  get(key) {
    const data = this.cache.get(key);
    if (!data) {
      return null;
    }
    if (Date.now() - data.createdAt > this.ttl) {
      this.cache.delete(key);
      return null;
    }
    return data.value;
  }
  set(key, value) {
    this.cache.set(key, { createdAt: Date.now(), value });
  }
};
var Analytics = class {
  redis;
  prefix;
  bucketSize;
  retention;
  cache = new Cache(6e4);
  constructor(config) {
    this.redis = config.redis;
    this.prefix = config.prefix ?? "@upstash/analytics";
    this.bucketSize = this.parseWindow(config.window);
    this.retention = config.retention ? this.parseWindow(config.retention) : void 0;
  }
  validateTableName(table) {
    const regex = /^[a-zA-Z0-9_-]+$/;
    if (!regex.test(table)) {
      throw new Error(
        `Invalid table name: ${table}. Table names can only contain letters, numbers, dashes and underscores.`
      );
    }
  }
  parseWindow(window) {
    if (typeof window === "number") {
      if (window <= 0) {
        throw new Error(`Invalid window: ${window}`);
      }
      return window;
    }
    const regex = /^(\d+)([smhd])$/;
    if (!regex.test(window)) {
      throw new Error(`Invalid window: ${window}`);
    }
    const [, valueStr, unit] = window.match(regex);
    const value = parseInt(valueStr);
    switch (unit) {
      case "s":
        return value * 1e3;
      case "m":
        return value * 1e3 * 60;
      case "h":
        return value * 1e3 * 60 * 60;
      case "d":
        return value * 1e3 * 60 * 60 * 24;
      default:
        throw new Error(`Invalid window unit: ${unit}`);
    }
  }
  async ingest(table, ...events) {
    this.validateTableName(table);
    await Promise.all(
      events.map(async (event) => {
        const time = event.time ?? Date.now();
        const bucket = Math.floor(time / this.bucketSize) * this.bucketSize;
        const key = [this.prefix, table, bucket].join(":");
        await this.redis.hincrby(
          key,
          JSON.stringify({
            ...event,
            time: void 0
          }),
          1
        );
      })
    );
  }
  async loadBuckets(table, opts) {
    this.validateTableName(table);
    const now = Date.now();
    const keys = [];
    if (opts.scan) {
      let cursor = 0;
      const match = [this.prefix, table, "*"].join(":");
      do {
        const [nextCursor, found] = await this.redis.scan(cursor, {
          match
        });
        cursor = nextCursor;
        for (const key of found) {
          const timestamp = parseInt(key.split(":").pop());
          if (this.retention && timestamp < now - this.retention) {
            await this.redis.del(key);
            continue;
          }
          if (timestamp >= opts.range[0] || timestamp <= opts.range[1]) {
            keys.push(key);
          }
        }
      } while (cursor !== 0);
    } else {
      let t = Math.floor(now / this.bucketSize) * this.bucketSize;
      while (t > opts.range[1]) {
        t -= this.bucketSize;
      }
      while (t >= opts.range[0]) {
        keys.push([this.prefix, table, t].join(":"));
        t -= this.bucketSize;
      }
    }
    const loadKeys = [];
    const buckets = [];
    for (const key of keys) {
      const cached = this.cache.get(key);
      if (cached) {
        buckets.push({
          key,
          hash: cached
        });
      } else {
        loadKeys.push(key);
      }
    }
    const p = this.redis.pipeline();
    for (const key of loadKeys) {
      p.hgetall(key);
    }
    const res = loadKeys.length > 0 ? await p.exec() : [];
    for (let i = 0; i < loadKeys.length; i++) {
      const key = loadKeys[i];
      const hash = res[i];
      if (hash) {
        this.cache.set(key, hash);
      }
      buckets.push({
        key,
        hash: hash ?? {}
      });
    }
    return buckets.sort((a, b) => a.hash.time - b.hash.time);
  }
  async count(table, opts) {
    this.validateTableName(table);
    const buckets = await this.loadBuckets(table, { range: opts.range });
    return await Promise.all(
      buckets.map(async ({ key, hash }) => {
        const timestamp = parseInt(key.split(":").pop());
        return {
          time: timestamp,
          count: Object.values(hash).reduce((acc, curr) => acc + curr, 0)
        };
      })
    );
  }
  async aggregateBy(table, aggregateBy, opts) {
    this.validateTableName(table);
    const buckets = await this.loadBuckets(table, { range: opts.range });
    const days = await Promise.all(
      buckets.map(async ({ key, hash }) => {
        const day = { time: Key.fromString(key).bucket };
        for (const [field, count] of Object.entries(hash)) {
          const r = JSON.parse(field);
          for (const [k, v] of Object.entries(r)) {
            const agg = r[aggregateBy];
            if (!day[agg]) {
              day[agg] = {};
            }
            if (k === aggregateBy) {
              continue;
            }
            if (!day[agg][v]) {
              day[agg][v] = 0;
            }
            day[agg][v] += count;
          }
        }
        return day;
      })
    );
    return days;
  }
  async query(table, opts) {
    this.validateTableName(table);
    const buckets = await this.loadBuckets(table, { range: opts.range });
    const days = await Promise.all(
      buckets.map(async ({ key, hash }) => {
        const day = { time: Key.fromString(key).bucket };
        for (const [field, count] of Object.entries(hash)) {
          const r = JSON.parse(field);
          let skip = false;
          if (opts?.where) {
            for (const [requiredKey, requiredValue] of Object.entries(opts.where)) {
              if (!(requiredKey in r)) {
                skip = true;
                break;
              }
              if (r[requiredKey] !== requiredValue) {
                skip = true;
                break;
              }
            }
          }
          if (skip) {
            continue;
          }
          for (const [k, v] of Object.entries(r)) {
            if (opts?.filter && !opts.filter.includes(k)) {
              continue;
            }
            if (!day[k]) {
              day[k] = {};
            }
            if (!day[k][v]) {
              day[k][v] = 0;
            }
            day[k][v] += count;
          }
        }
        return day;
      })
    );
    return days;
  }
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  Analytics
});
//# sourceMappingURL=index.js.map